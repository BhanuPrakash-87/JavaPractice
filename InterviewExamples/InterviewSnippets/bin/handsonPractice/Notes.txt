Immutable class, Collections, Threads, Singleton pattern, Solid principles, HashMap and concurrentHashMap,
Dependency injections, spring boot related, volatile, synchronized and atomic variables, API based questions

================================================================================================================================

S -> Single responsibility Principle
	 ex: "userController" class can have methods like "createUser", "deleteUser", "getUser" but not "showLogs".

O -> Open for extension and closed for modification
	 ex: We have a class "AreaOfShapes" and methods to calculate "areaOfCircle", "areaOfRectangle",
	 And we need to introduce "areaOfSquare" to calculate new area,
	 Instead of modifying "AreaOfShapes" class, Create an interface "AreaOfShapes" with "area" as abstract method,
	 Create new class "Square", implement "AreaOfShapes" interface and Override "area" method.

L -> Liskov substitution Principle
     Child classes should behave same as their parent class,
	 ex: "Bird" class has method "layEggs" and "fly",
	 Child classes "Parrot" and "Sparrow" can extend and Override "layEggs" and "fly" method,
	 But "Ostrich" class cannot Override "fly" method.
	 
	 So, Create a separate class "FlyingBird" and keep "fly" method (remove "fly" method from Bird class),
	 Now, "Ostrich" class can directly extend "Bird" class,
	 "FlyingBird" class can extend "Bird" class and child classes "Parrot" and "Sparrow" can extend "FlyingBird" class.
	 
I -> Interface segregation Principle
     Keep all supported methods in 1 interface and for others create separate interfaces.
	 ex: "ResturantMenu" Interface has methods "vegMenu", "nonVegMenu", "dessertsMenu" and "drinksMenu",
	 Class "VegResturant" cannot use "nonVegMenu" method from "ResturantMenu" Interface,
	 
	 So, Better create separate Interfaces for each "vegMenu", "nonVegMenu", "dessertsMenu" and "drinksMenu",
	 Now "VegResturant" class can implement whichever interface is required
	 
D -> Dependency inversion Principle
	 High-level modules should not depend on low-level modules, Instead both should depend on Abstractions, This help for loosely coupled code.
	 
	 ex: Low-level class "SendEmail" has "sendNotification" method, High-level class "NotificationService" depends on "SendEmail" object and calls "sendNotification" method to notify,
	 If new class "SendSMS" comes in and has "sendNotification" method, Then one more class "NotificationService1" will be required, depend on "SendSMS" object and calls "sendNotification" method to notify.
	 
	 Instead, Create an Interface "MessageSender" with "sendMessage" method (Abstraction),
	 Create low-level classes "EmailSender", "SMSSender" by implementing "sendMessage" Interface,
	 Create high-level class "NotificationService", Create an object of "MessageSender" and call "sendMessage" method.

================================================================================================================================

A -> Atomicity, Either whole transaction executes or none.
C -> Consistency, Database must have consistent state before and after a transaction.
I -> Isolation, Execution of a transaction should not interfere with execution of another transaction.
D -> Durability, The data must not be lost even if system fails.

================================================================================================================================


Dependency Injection is the actual implementation of IoC (Inversion of Control)
IoC is a principle, In Spring we use DI to achieve IoC.

================================================================================================================================

volatile -> We want to expose visibility of changes to a value for diferrent threads,
            Never cached, read directly from main memory,
            Can only be used for field declarations,
            Methods, Classes, Local variable and parameters cannot be volatile,
            Use when the variable is read frequently but not modified frequently,
            volatile does not gurantee Atomicity.
Atomicity -> This is achieved by synchronized,
synchronized -> Can be used on methods or block of code,
             Only 1 thread can execute a block of code at a given time.
Visibility -> Changes done by 1 thread are visible to other threads.
Atomic Variables -> Operations on these variables, such as incrementAndGet(), compareAndSet(), or getAndSet(), are guaranteed to be atomic.
                    This means they are executed as a single, uninterrupted unit of work, even in the presence of multiple threads.

My learning -> If a volatile variable is updated and in between if another thread trying to read the value,
               There is a chance that it still reads old value and not the updated value,
               In this case of multi threaded environment, We need to use Atomic variables.
When to use Atomic variables?
I have update operation on a shared variable, I don't want to use heavy duty synchronization.

================================================================================================================================

HashMap                                                concurrentHashMap
> Not synchronized (Multiple operation at a time)      > Synchronized (One operation at a time)
> Not thread safe                                      > Thread safe
> Fail-Fast (Exception during Iteration)               > Fail-Safe (Performs iteration by multiple threads)
> Allows null keys and values                          > Does not allows null keys/values
> Faster than concurrentHashMap                        > Slower than HashMap

================================================================================================================================

Comparator is an interface using which we can specify our own logic for sorting by overriding compare(Object obj1, Object obj2) method.
Defines custom ordering logic for objects, external to the class.

Comparable is also an interface where we give the power to class itself to compare its objects,
Defines the natural ordering of objects within the class itself.

================================================================================================================================

Spring Security:
User input -> Server -> Spring Security Filters (F1, F2, ....) -> Dispatcher Servlet -> Controller